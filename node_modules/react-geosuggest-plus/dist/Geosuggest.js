/* global google */
/* eslint react/jsx-sort-prop-types: 0, react/sort-comp: 0, react/prop-types: 0 */
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _GeosuggestItem = require('./GeosuggestItem');

var _GeosuggestItem2 = _interopRequireDefault(_GeosuggestItem);

var Geosuggest = (function (_React$Component) {
  _inherits(Geosuggest, _React$Component);

  function Geosuggest() {
    _classCallCheck(this, Geosuggest);

    _get(Object.getPrototypeOf(Geosuggest.prototype), 'constructor', this).apply(this, arguments);

    this.state = {
      isSuggestsHidden: true,
      userInput: this.props.initialValue,
      activeSuggest: null,
      suggests: [], // google predictions
      recents: [] // recent/saved addresses
    };
  }

  _createClass(Geosuggest, [{
    key: 'componentDidMount',

    /**
     * Called on the client side after component is mounted.
     * Google api sdk object will be obtained and cached as a instance property.
     * Necessary objects of google api will also be determined and saved.
     */
    value: function componentDidMount() {
      this.setInputValue(this.props.initialValue);

      var googleMaps = this.props.googleMaps || google && google.maps || this.googleMaps;

      if (!googleMaps) {
        console.error('Google map api was not found in the page.');
      } else {
        this.googleMaps = googleMaps;
      }

      this.autocompleteService = new googleMaps.places.AutocompleteService();
      this.geocoder = new googleMaps.Geocoder();
      this._isMounted = true;
    }

    /**
     * Change inputValue if prop changes
     * @param {Object} props The new props
     */
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(props) {
      if (this.props.initialValue !== props.initialValue) {
        this.setState({ userInput: props.initialValue });
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this._isMounted = false;
    }

    /**
     * Method used for setting initial value.
     * @param {string} value to set in input
     */
  }, {
    key: 'setInputValue',
    value: function setInputValue(value) {
      this.setState({
        userInput: value
      });
    }

    /**
     * When the input got changed
     */
  }, {
    key: 'onInputChange',
    value: function onInputChange() {
      var _this = this;

      var userInput = this.refs.geosuggestInput.value;

      this.setState({ userInput: userInput }, function () {
        _this.showSuggests();
        _this.props.onChange(userInput);
      });
    }

    /**
     * When the input gets focused
     */
  }, {
    key: 'onFocus',
    value: function onFocus() {
      this.props.onFocus();
      this.showSuggests();
    }
  }, {
    key: 'onClick',
    value: function onClick() {
      this.props.onClick();
    }

    /**
     * Click the clear button
     */
  }, {
    key: 'onClearClick',
    value: function onClearClick() {
      var _this2 = this;

      this.clear(function () {
        return _this2.refs.geosuggestInput.focus();
      });
      this.props.onClearClick();
    }

    /**
     * Update the value of the user input
     * @param {String} value the new value of the user input
     */
  }, {
    key: 'update',
    value: function update(value) {
      this.setState({ userInput: value });
      this.props.onChange(value);
    }

    /*
     * Clear the input and close the suggestion pane
     * () => this.hideSuggests()
     *
     */
  }, {
    key: 'clear',
    value: function clear() {
      var cb = arguments.length <= 0 || arguments[0] === undefined ? function () {} : arguments[0];

      this.setState({
        userInput: ''
      }, cb);
    }

    /**
     * Search for new suggests
     */
  }, {
    key: 'searchSuggests',
    value: function searchSuggests() {
      var _this3 = this;

      if (!this.state.userInput) {
        this.updateSuggests();
        return;
      }

      var options = {
        input: this.state.userInput
      };

      if (this.props.location) {
        options.location = this.props.location;
      }

      if (this.props.radius) {
        options.radius = this.props.radius;
      }

      if (this.props.bounds) {
        options.bounds = this.props.bounds;
      }

      if (this.props.types) {
        options.types = this.props.types;
      }

      if (this.props.country) {
        options.componentRestrictions = {
          country: this.props.country
        };
      }

      this.autocompleteService.getPlacePredictions(options, function (suggestsGoogle) {
        _this3.updateSuggests(suggestsGoogle);

        if (_this3.props.autoActivateFirstSuggest) {
          _this3.activateSuggest('next');
        }
      });
    }

    /**
     * Update the suggests
     * @param  {Object} suggestsGoogle The new google suggests
     */
  }, {
    key: 'updateSuggests',
    value: function updateSuggests(suggestsGoogle) {
      var _this4 = this;

      if (!suggestsGoogle) {
        suggestsGoogle = [];
      }

      var suggests = [];
      var recents = [];
      var regex = new RegExp(this.state.userInput, 'gim');
      var skipSuggest = this.props.skipSuggest;

      var index = 0;
      var fixturesLen = this.props.fixtures.length;
      var limit = fixturesLen > this.props.recentsLimit ? this.props.recentsLimit : fixturesLen;
      // ugh i hate for-loops but seems like i have to
      // utilize it here so i can break out
      for (; index < fixturesLen; index++) {
        var recent = this.props.fixtures[index];
        recent.placeId = recent.id;
        recent.altLabel = this.props.getRecentLabel(recent);
        recents.push(recent);
      }

      suggestsGoogle.forEach(function (suggest) {
        if (!skipSuggest(suggest)) {
          suggests.push({
            label: _this4.props.getSuggestLabel(suggest),
            placeId: suggest.place_id
          });
        }
      });

      this.setState({ suggests: suggests });
      this.setState({ recents: recents });
    }

    /**
     * When the input gets focused
     */
  }, {
    key: 'showSuggests',
    value: function showSuggests() {
      this.searchSuggests();
      this.setState({ isSuggestsHidden: false });
    }

    /**
     * When the input loses focused
     */
  }, {
    key: 'hideSuggests',
    value: function hideSuggests() {
      var _this5 = this;

      this.props.onBlur();
      setTimeout(function () {
        if (_this5._isMounted) {
          _this5.setState({ isSuggestsHidden: true });
        }
      }, 500);
    }

    /**
     * When a key gets pressed in the input
     * @param  {Event} event The keypress event
     */
  }, {
    key: 'onInputKeyDown',
    value: function onInputKeyDown(event) {
      switch (event.which) {
        case 40:
          // DOWN
          event.preventDefault();
          this.activateSuggest('next');
          break;
        case 38:
          // UP
          event.preventDefault();
          this.activateSuggest('prev');
          break;
        case 13:
          // ENTER
          event.preventDefault();
          // If activeSuggest is populated
          // then proceed as expected
          if (this.state.activeSuggest) {
            this.selectSuggest(this.state.activeSuggest);
          }
          // If the user has inputted text
          // AND there are suggestions,
          // we'll default to the first suggestion
          else if (this.state.userInput && this.state.suggests.length) {
              this.selectSuggest(this.state.suggests[0]);
            }
            // Cascades down to just checking
            // if the user has entered text
            // We'll just defer to component `onEmptySuggests`
            else if (this.state.userInput) {
                this.props.onEmptySuggests();
              }
          break;
        case 9:
          // TAB
          this.selectSuggest(this.state.activeSuggest);
          break;
        case 27:
          // ESC
          this.hideSuggests();
          break;
        default:
          break;
      }
    }

    /**
     * Activate a new suggest
     * @param {String} direction The direction in which to activate new suggest
     */
  }, {
    key: 'activateSuggest',
    value: function activateSuggest(direction) {
      // eslint-disable-line
      if (this.state.isSuggestsHidden) {
        this.showSuggests();
        return;
      }

      var suggestsLength = this.state.suggests.length;
      var recentsLength = this.state.recents.length;
      var recentsCount = recentsLength > this.props.recentsLimit ? this.props.recentsLimit : recentsLength;
      var suggestsCount = recentsCount + suggestsLength - 1,
          next = direction === 'next',
          newActiveSuggest = null,
          newIndex = 0,
          i = 0; // eslint-disable-line id-length

      for (i; i <= suggestsCount; i++) {
        if (this.state.suggests[i] === this.state.activeSuggest || this.state.recents[i] === this.state.activeSuggest) {
          newIndex = next ? i + 1 : i - 1;
        }
      }

      if (!this.state.activeSuggest) {
        newIndex = next ? 0 : suggestsCount;
      }

      if (newIndex >= 0 && newIndex <= suggestsCount) {
        // if suggests not full but recents is
        if (!suggestsLength && recentsCount) {
          newActiveSuggest = this.state.recents[newIndex];
        } else if (suggestsLength && recentsCount && newIndex >= suggestsLength) {
          newActiveSuggest = this.state.recents[newIndex];
        } else {
          newActiveSuggest = this.state.suggests[newIndex];
        }
      }

      this.setState({ activeSuggest: newActiveSuggest });
    }

    /**
     * When an item got selected
     * @param {GeosuggestItem} suggest The selected suggest item
     */
  }, {
    key: 'selectSuggest',
    value: function selectSuggest(suggest) {
      if (!suggest) {
        suggest = {
          label: this.state.userInput
        };
      }

      this.setState({
        isSuggestsHidden: true,
        userInput: suggest.label || suggest.altLabel
      });

      if (suggest.location) {
        this.props.onSuggestSelect(suggest);
        return;
      }

      this.geocodeSuggest(suggest);
    }

    /**
     * Geocode a suggest
     * @param  {Object} suggest The suggest
     */
  }, {
    key: 'geocodeSuggest',
    value: function geocodeSuggest(suggest) {
      var _this6 = this;

      var searchObject = undefined;
      if (suggest.altLabel) {
        searchObject = {
          address: suggest.altLabel
        };
      } else if (suggest.placeId) {
        searchObject = {
          placeId: suggest.placeId
        };
      }
      this.geocoder.geocode(searchObject, function (results, status) {
        if (status !== _this6.googleMaps.GeocoderStatus.OK) {
          return;
        }

        var gmaps = results[0],
            location = gmaps.geometry.location;

        suggest.gmaps = gmaps;
        suggest.location = {
          lat: location.lat(),
          lng: location.lng()
        };

        _this6.props.onSuggestSelect(suggest);
      });
    }

    /**
     * Get the recent/saved items for the list
     * @return {Array} The recent/saved items
     */
  }, {
    key: 'getRecentItems',
    value: function getRecentItems() {
      var _this7 = this;

      return this.state.recents.map(function (suggest, index) {
        var isActive = _this7.state.activeSuggest && suggest.placeId === _this7.state.activeSuggest.placeId;

        // shut off at the recentsLimit
        if (index >= _this7.props.recentsLimit) {
          return;
        }

        return (// eslint-disable-line no-extra-parens
          _react2['default'].createElement(_GeosuggestItem2['default'], {
            key: suggest.placeId,
            suggest: suggest,
            isActive: isActive,
            onSuggestSelect: _this7.selectSuggest.bind(_this7) })
        );
      });
    }

    /**
     * Get the suggest items for the list
     * @return {Array} The suggestions
     */
  }, {
    key: 'getSuggestItems',
    value: function getSuggestItems() {
      var _this8 = this;

      return this.state.suggests.map(function (suggest, index) {
        var isActive = _this8.state.activeSuggest && suggest.placeId === _this8.state.activeSuggest.placeId;

        return (// eslint-disable-line no-extra-parens
          _react2['default'].createElement(_GeosuggestItem2['default'], {
            key: suggest.placeId,
            suggest: suggest,
            isActive: isActive,
            onSuggestSelect: _this8.selectSuggest.bind(_this8) })
        );
      });
    }

    /**
     * The classes for the suggests list
     * @return {String} The classes
     */
  }, {
    key: 'getSuggestsClasses',
    value: function getSuggestsClasses() {
      var classes = 'geosuggest__suggests';

      classes += this.state.isSuggestsHidden ? ' geosuggest__suggests--hidden' : '';

      return classes;
    }
  }, {
    key: 'getContainerClasses',
    value: function getContainerClasses() {
      var classes = 'geosuggest-window row';

      classes += this.state.isSuggestsHidden ? ' geosuggest__suggests--hidden hidden' : '';

      return classes;
    }

    /**
     * Render the view
     * @return {Function} The React element to render
     */
  }, {
    key: 'render',
    value: function render() {
      var _this9 = this;

      var suggestionsSection = function suggestionsSection() {};
      var recentsSection = function recentsSection() {};
      if (!!this.state.suggests.length) {
        suggestionsSection = function () {
          return _react2['default'].createElement(
            'div',
            { className: 'geosuggest-suggestions' },
            _react2['default'].createElement(
              'span',
              { className: 'geosuggest-label allcaps' },
              'Suggestions'
            ),
            _react2['default'].createElement(
              'ul',
              { className: 'geosuggest__suggests' },
              _this9.getSuggestItems()
            )
          );
        };
      } else if (this.state.userInput) {
        suggestionsSection = this.props.noSuggestionsMarkup;
      }

      if (!!this.state.recents.length) {
        recentsSection = function () {
          return _react2['default'].createElement(
            'div',
            { className: 'geosuggest-recents' },
            _react2['default'].createElement(
              'span',
              { className: 'geosuggest-label allcaps' },
              'Recent Addresses'
            ),
            _react2['default'].createElement(
              'ul',
              { className: 'geosuggest__recents' },
              _this9.getRecentItems()
            )
          );
        };
      }
      return _react2['default'].createElement(
        'div',
        { className: 'geosuggest-container ' + this.props.className },
        _react2['default'].createElement('input', {
          className: 'geosuggest__input',
          ref: 'geosuggestInput',
          type: 'text',
          value: this.state.userInput,
          placeholder: this.props.placeholder,
          disabled: this.props.disabled,
          onKeyDown: this.onInputKeyDown.bind(this),
          onChange: this.onInputChange.bind(this),
          onFocus: this.onFocus.bind(this),
          onClick: this.onClick.bind(this),
          onBlur: this.hideSuggests.bind(this) }),
        !!this.state.userInput && _react2['default'].createElement('button', { className: 'icon icon-close geosuggest-clear', onClick: this.onClearClick.bind(this) }),
        _react2['default'].createElement(
          'div',
          { className: this.getContainerClasses() },
          suggestionsSection(),
          recentsSection()
        ),
        this.props.showButton && this.props.buttonMarkup()
      );
    }
  }]);

  return Geosuggest;
})(_react2['default'].Component);

Geosuggest.propTypes = {
  autoActivateFirstSuggest: _react2['default'].PropTypes.bool,
  bounds: _react2['default'].PropTypes.any,
  className: _react2['default'].PropTypes.string,
  country: _react2['default'].PropTypes.any,
  disabled: _react2['default'].PropTypes.bool,
  fixtures: _react2['default'].PropTypes.array,
  getRecentLabel: _react2['default'].PropTypes.func,
  getSuggestLabel: _react2['default'].PropTypes.func,
  googleMaps: _react2['default'].PropTypes.any,
  initialValue: _react2['default'].PropTypes.string,
  location: _react2['default'].PropTypes.any,
  onBlur: _react2['default'].PropTypes.func,
  onChange: _react2['default'].PropTypes.func,
  onClearClick: _react2['default'].PropTypes.func,
  onFocus: _react2['default'].PropTypes.func,
  onClick: _react2['default'].PropTypes.func,
  onSuggestSelect: _react2['default'].PropTypes.func,
  placeholder: _react2['default'].PropTypes.string,
  radius: _react2['default'].PropTypes.any,
  skipSuggest: _react2['default'].PropTypes.func,
  types: _react2['default'].PropTypes.any,
  recentsLimit: _react2['default'].PropTypes.any,
  showButton: _react2['default'].PropTypes.bool,
  buttonMarkup: _react2['default'].PropTypes.func
};

Geosuggest.defaultProps = {
  fixtures: [],
  initialValue: '',
  placeholder: 'Search places',
  disabled: false,
  className: '',
  location: null,
  radius: null,
  bounds: null,
  country: null,
  types: null,
  googleMaps: null,
  onSuggestSelect: function onSuggestSelect() {},
  onFocus: function onFocus() {},
  onBlur: function onBlur() {},
  onClick: function onClick() {},
  onChange: function onChange() {},
  onClearClick: function onClearClick() {},
  skipSuggest: function skipSuggest() {},
  getRecentLabel: function getRecentLabel(recent) {
    return recent.zipcode;
  },
  getSuggestLabel: function getSuggestLabel(suggest) {
    return suggest.description;
  },
  autoActivateFirstSuggest: false,
  recentsLimit: 5,
  showButton: false,
  buttonMarkup: function buttonMarkup() {
    return _react2['default'].createElement(
      'button',
      null,
      'Enter'
    );
  },
  noSuggestionsMarkup: function noSuggestionsMarkup() {},
  onEmptySuggests: function onEmptySuggests() {}
};

exports['default'] = Geosuggest;
module.exports = exports['default'];

/**
 * Get the initial state
 */
